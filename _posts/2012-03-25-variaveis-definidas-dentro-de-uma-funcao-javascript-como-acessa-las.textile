---
layout: post
title: Variáveis declaradas no contexto uma função JavaScript, como acessá-las?
categories: [javascript]
tags: [javascript, var, contexto, escopo]
meta_keywords: javascript, var, contexto, escopo
meta_description: JavaScript é tão dinâmico que podemos criar soluções que não existem na linguagem
---
JavaScript é tão dinâmico que podemos criar soluções que não existem na linguagem.

Até onde sabemos não é possível acessar variáveis declaradas no contexto de uma função.

h3. Como funciona o escopo de variável em JavaScript

Em JavaScript temos dois tipos de "escopo de variável":https://developer.mozilla.org/en/JavaScript/Guide/Values,_Variables,_and_Literals, local e global. Toda variável declarada sem a instrução "<code>var</code>":https://developer.mozilla.org/en/JavaScript/Reference/Statements/var será definida no contexto do objeto global ( <code>window</code> nos browsers ) e também será global se for definida com a instrução <code>var</code> no contexto global.

Ou seja:

{% highlight javascript %}
var a = 1;
b = 2;

function doNothing() {
    var c = 3;
    d = 4;
};

doNothing();

console.log(a); // global
console.log(b); // global
console.log(c); // local ReferenceError c is not defined
console.log(d); // global
{% endhighlight %}

h3. Funções construtoras retornam objetos

Funções construtoras retornam objetos contendo as propriedades e métodos definidos:

{% highlight javascript %}
function Car(){
    var secretKey = '#$(**dwd73451#)&@!';
    this.type = 'flex';
    this.km = 0;
}

Car.prototype.run = function(km){
    this.km+=km;
    return this.km;
}

var golf = new Car();
console.log(gol); // Car { type="flex", km=0, run=function()}
{% endhighlight %}

Não temos como acessar a variavel <code>secretKey</code>, porem se implementarmos um método dentro da função construtora <code>Car</code> o mesmo terá acesso a variável <code>secretKey</code>:

{% highlight javascript %}
function Car(){
    var secretKey = '#$(**dwd73451#)&@!';
    this.type = 'flex';
    this.km = 0;
    this.getSecretKey = function(){
        return secretKey
    }
}
var golf = new Car();
golf.getSecretKey(); // #$(**dwd73451#)&@!
{% endhighlight %}

Pelo que vimos aqui os requesitos seriam:
    * A função deveria ser usada como um construtor
    * Implementar um método que retornasse as variáveis


Implementando um novo método no objeto "<code>Function</code>":https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function


{% highlight javascript %}
Function.prototype.expose = function( private ){
    
    // this se refere a função atual
    
    // propriedade que contera a instancia da função mofificada
    this.fn = this.fn || undefined;

    if ( this.fn ){
        // se já houver uma instancia apenas chama o método get
        return this.fn.get( private )
    };
    
    // função que sera adicionada a a função modificada para retornar as variáveis
    var get = function( v ){
        return eval( v );
    };
    
    // this.toString() retorna o código fonte da função
    var fnSource = this.toString().match( /function.+?\((.*)\).+?\{([\s\S]*)\}/ );
    
    // aqui está o segredo, criar uma nova função usando o objeto Function
    // passando a string do código fonte e adicionando o novo método get
    var F = new Function( fnSource[1],'this.get='+get+';'+fnSource[2] );
    
    // usamos F como construtor e armazenamos uma instância em this.fn para futuros acessos
    this.fn = new F;
    
    // Function.prototype.expose retorna o resultado do método get
    return this.fn.get(private);
}
{% endhighlight %}

Alguns testes:

{% highlight javascript %}
var fn = function() {
    var c = 1;
    return c;
};

var fn2 = function() {
    var a = 1;
    if( a > 0 ){
        a=10;
    }
    return a;
};

var config = function() {
    var url = 'http://10.42.43.100';
    var privateKey = '#aˆ&$DU)DI)RQ#@#$%ˆFHGFOIJE%$#$#%(';
};

console.log( fn.expose('c') );
console.log( fn2.expose('a') );
console.log( config.expose('privateKey') );
{% endhighlight %}

h3. Conclusões

Como vimos é possível quebrar o escopo de uma variável em JavaScript, talvez de uma maneira não muito elegante ( <code>eval</code>, <code>toString</code> ) e com algumas limitações de uso.

Sinceramente nunca precisei usar esse artificio, essa solução (baseada na referência abaixo) foi apenas para demonstrar essa curiosidade da linguagem.

h4. Referências

* "Puncture Closures to Create Wormholes":http://appden.com/javascript/puncture-closures/
